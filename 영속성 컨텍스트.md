# 엔티티 메니저 팩토리

### **3.1 엔티티 매니저 팩토리와 엔티티 매니저**

> 데이터베이스를 하나만 사용하는 어플리케이션은 일반적으로 EntityManagerFactory를 하나만 생성.
> 

**EntityManagerFactory를 얻기**

```java
// 비용이 아주 많이 든다.
//엔티티 매니저 팩토리 생성
EntityManagerFactory emf = Persistence.createEntityManagerFactory("jpabook");

```

- 만드는 비용이 상당히 큼.
- 한 개만 만들어서 어플리케이션 전체에서 공유하도록 설계.
- 여러 스레드가 동시에 접근해도 안전, 서로 다른 스레드 간 공유 가능.

**EntityManger 생성**

```java
// 엔티티 매니저 생성, 비용이 거의 안든다.
EntityManager em = emf.createEntityManager(); //엔티티 매니저 생성
```

- 여러 스레드가 동시에 접근하면 동시성 문제 발생
- **스레드간 절대 공유하면 안된다**.
- 데이터베이스 연결이 필요한 시점까지 커넥션을 얻지 않는다.

![https://ultrakain.gitbooks.io/jpa/content/chapter3/images/JPA_3_1.png](https://ultrakain.gitbooks.io/jpa/content/chapter3/images/JPA_3_1.png)

하이버네이트를 포함한 JPA 구현체들을 EntityManagerFactory를 생성할 때 DB 커넥션 풀도 만드는 데, EntityManger가 바로 DB 커넥션을 얻는 것이 아니라, 사용되는 시점에 얻는다.

### **영속성 컨텍스트(persistence context)**

- 엔티티를 영구 저장하는 환경
- EntityManger로 Entity를 저장하거나 조회하면, 영속성 컨텍스트에 엔티티를 보관하고 관리된다.

```java
em.persist(member);
```

- 회원 엔티티 저장
- 엔티티 매니저를 사용해서 회원 엔티티를 **`영속성 컨텍스트`**에 저장

영속성 컨텍스는 엔티티 매니저를 생성할 때 하나 만들어진다. **`엔티티 매니저를 통해 영속성 컨텍스트에 접근하고 관리`**할 수 있다.

### **3.3 엔티티의 생명주기**

- 비영속(new/transient) : 영속성 컨텍스트와 전혀 관계가 없는 상태
- 영속(managed) : 영속성 컨텍스트에 저장된 상태
- 준영속(detached) : 영속성 컨테그트에 저장되었다가 분리된 상태
- 삭제(removed) : 삭제된 상태

## 

![https://ultrakain.gitbooks.io/jpa/content/chapter3/images/JPA_3_2.png](https://ultrakain.gitbooks.io/jpa/content/chapter3/images/JPA_3_2.png)

**비영속**

- 엔티티 객체를 생성.
- **`순수한 객체 상태, 아직 저장하지 않음.`**
- 영속성 컨텍스트나 데이터베이스와 상관없음.

```java
// 객체를 생성한 상태(비영속)
Member member = new Member();
member.setId(100L);
member.setUsername("회원1");

```

`em.persist()` 호출 전까지는  비영속 상태 이다.

**영속**

- 엔티티 매니저를 통해 엔티티를 영속성 컨텍스트에 저장.
- 영속성 컨텍스트가 관리하는 엔티티를 영속 상태.
- 회원 엔티티 : **비영속 상태** => **영속 상태**
- **`영속상태 = 영속성 컨텍스트에 의해 관리된다.`**
- **em.find()**나 **JPQL를 사용해서 조회한 엔티티**도 영속 상태.

```java
// 객체를 저장한 상태(영속)
em.persist(member);
```

em.persist() 호출 후는 영속상태

**준영속**

- 영속성 컨텍스트가 관리하던 영속 상태의 엔티티를 영속성 컨텍스트가 관리하지 않으면 **준영속 상태**
- **em.detach()** 호출로 준영속 상태 명시적 호출.
- **em.close()**를 호출해서 영속성 컨텍스트를 닫음.
- **em.clear**로 영속성 컨텍스트 초기화.
  
    ```java
    // 회원 엔티티를 영속성 컨텍스트에서 분리, 준영속 상태
    em.detach(member);
    ```
    

여기서 든 의문은

비영속, 준영속 이라는 두 가지의 개념을 둔 이유가 뭘까?였다.

뭐… 준영속은 이미 한번 영속상태가 되었으니깐 식별자 값을 무조건 가지고 있는 다는 점을 다르지만,

어쨋든 비영속, 준영속 둘다 영속성 컨텍스트가 관리하지 않는다는 점은 같기 떄문이다.

+알아보니 이부분이 지연로딩과 관련있다고 한다. 나중에 알아보기로..

**삭제**

엔티티를 영속성 컨텍스트와 데이타베이스에서 삭제.

```java
// 객체를 삭제한 상태(삭제)
em.remove(member);
```

### **3.4 영속성 컨텍스트의 특징**

- 영속성 컨텍스트와 식별자 값
    - 엔티티를 **식별자 값(@id로 테이블의 기본 키와 매핑한 값)으로 구분**
    - 영속 상태는 식별자 값이 반드시 있어야 한다.
    - 식별자 값이 없으면 예외 발생.
- 영속성 컨텍스트와 데이터베이스 저장
    - JPA는 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영
    - 플러시(flush)
- 영속성 컨텍스트가 엔티티를 관리하는 것의 장점
    - 1차 캐시
    - 동일성 보장
    - 트랜잭션을 지원하는 쓰기 지연
    - 변경 감지
    - 지연 로딩

### **3.4.1 엔티티 조회**

- 영속성 컨텍스트는 내부에 캐시를 가지고 있음 => 1차 캐시
- 영속 상태의 엔티티는 모두 이곳에 저장

> 영속성 컨텍스트 내부에 Map이 하나 있음 : 키는 @Id로 매핑한 식별자이고 값은 엔티티 instance
> 

```java
// 엔티티를 생성한 상태(비영속)
Member member = new Member();
member.setId(100L);
member.setUsername("회원1");

// 엔티티 영속
em.persist(member);

```

- **1차 캐시의 키는 식별자 값**
- 식별자 값은 데이타베이스 기본 키와 매핑
- 영속성 컨텍스트에 데이터를 저장하고 조회하는 모든 기준은 데이타베이스 기본 키 값.

**엔티티 조회**

```java
Member member = em.find(Member.class, 100L);
```

**중요한 부분**

> em.find() 호출 => 1차 캐시에서 엔티티 조회 후, 엔티티가 1차 캐시에 없으면 데이터베이스 조회
> 

**1차 캐시에서 조회**

- em.find() 호출
    - 우선 1차 캐시에서 식별자 값으로 엔티티 찾음.
    - 찾는 엔티티가 있으면 데이타베이스 조회하지 않고, 메모리에 있는 1차 캐시에서 엔티티를 조회

**1차 캐시에 있는 엔티티 조회**

```java
package jpabook.jpashop;

import jpabook.jpashop.domin.Member;
import jpabook.jpashop.domin.Order;
import jpabook.jpashop.domin.OrderItem;

import javax.persistence.*;
import java.util.List;

public class JpaMain {
    public static void main(String[] args) {

        EntityManagerFactory emf1 = Persistence.createEntityManagerFactory("hello");

        EntityManager em1 = emf1.createEntityManager();

        EntityTransaction tx1 = em1.getTransaction();
        tx1.begin();

        try {
            Member member=new Member();
            member.setName("김수민");
            em1.persist(member);
            Member findMember= em1.find(Member.class,1L);
            System.out.println(findMember.getId());
            tx1.commit();

        } catch (Exception e) {
            tx1.rollback();

        } finally {
            em1.close();

        }
        emf1.close();

    }
}
```

```java
Hibernate: 
    /* insert jpabook.jpashop.domin.Member
        */ insert 
        into
            Member
            (name, MEMBER_ID) 
        values
            (?, ?)

```

select 쿼리는 안 나갔다. → 1차 캐시에서 조회했기 때문

**데이터베이스에서 조회**

- 엔티티가 1차 캐시에 없으면 엔티티 매니저는 데이터베이스를 조회해서 엔티티를 생성.
- 1차 캐시에 저장한 후에 영속 상태의 엔티티를 반환.

**분석**

1. em.find(Member.class, 200L)를 실행.
2. member2가 1차 캐시에 없으므로 데이터베이스에서 조회.
3. 조회한 데이터로 member2 엔티티를 생성해서 1차 캐시에 저장한다.(영속상태)
4. 조회한 엔티티를 반환

### **영속 엔티티의 동일성 보장**

```java
Member a = em.find(Member.class, "member1");
Member b = em.find(Member.class, "member1");

System.out.println(a == b); // 동일성 비교
```

- 결과는 "**참**"
- 둘은 같은 인스턴스
- **영속성 컨텍스트는 성능상 이점과 엔티티의 동일성을 보장한다.**

### **3.4.2 엔티티 등록**

**엔티티 등록 코드**

```java
EntityManager em = emf.createEntityManager();
EntityTransaction transaction = em.getTransaction();

// 엔티티 매니저는 데이터 변경 시 트랜잭션을 시작해야 한다.
transaction.begin();    // 트랜잭션 시작

em.persist(memberA);
em.persist(memberB);
// 여기까지 INSERT SQL을 데이터베이스에 보내지 않는다.

// 커밋하는 순간 데이터베이스에 INSERT SQL을 보낸다.
transaction.commit();   // 트랜잭션 커밋

```

- 엔티티 매니저는 트랜잭션을 커밋하기 직전까지 데이터베이스의 엔티티를 저장하지 않음.
- 내부 쿼리 저장소에 INSERT SQL을 차곡차곡 모아둔다.
- 트랜잭션 커밋할 때 모아둔 쿼리를 데이터베이스에 보낸다.
- **트랜잭션을 지원하는 쓰기 지연**

### **3.4.3 엔티티 수정**

- JPA는 엔티티를 **`수정할 때는 단순히 엔티티를 조회해서 데이터만 변경`**하면 된다.
- dirty checking 기능을 사용해서 데이타베이스에 자동 반영

![https://ultrakain.gitbooks.io/jpa/content/chapter3/images/JPA_3_11.png](https://ultrakain.gitbooks.io/jpa/content/chapter3/images/JPA_3_11.png)

> 플러시 시점에 스냅샷과 엔티티를 비교
> 

### **수정 순서**

1. 트랜잭션 커밋 -> 엔티티 매니저 내부에서 먼저 플러시 호출
2. 엔티티와 스냅샷을 비교해서 변경된 엔티티 찾는다.
3. 변경된 엔티티가 있으면 수정 쿼리를 생성해서 **쓰기 지연 SQL 저장소**로 보낸다.
4. 쓰기 지연 저장소의 SQL을 데이터베이스로 보낸다.
5. 데이터베이스 트랜잭션을 커밋

> 변경감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용된다.
> 

### **업데이트 기본 전략**

> JPA의 기본전략은 모든 필드를 업데이트한다.
> 
- 모든 필드를 사용하면 수정 쿼리가 항상 같음.
- 동일한 쿼리를 보내면 데이터베이스는 이전에 파싱된 쿼리는 재사용.

수정된 데이터만 사용해서 동적으로 UPDATE SQL을 생성

### @DynamicUpdate 와의 비교

저번 프로젝트 할 떄, 변경된 필드를 @DynamicUpdate 가 인지하여 이를 바꿔주었는데 이는 Dirty checking 방식과 유사한거 같아서, 차이점을 알아보려고 한다.

우선 DynamicUpdate 가 없을 떄

```java
package jpabook.jpashop.domin;

import org.hibernate.annotations.DynamicUpdate;

import javax.persistence.*;
import java.util.ArrayList;
import java.util.List;

@Entity
public class Member {

    @Id
    @GeneratedValue
    @Column(name="MEMBER_ID")
    private Long id;
    private String name;

    private String nickName;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getNickName() {
        return nickName;
    }

    public void setNickName(String nickName) {
        this.nickName = nickName;
    }
}
```

```java
package jpabook.jpashop;

import jpabook.jpashop.domin.Member;
import jpabook.jpashop.domin.Order;
import jpabook.jpashop.domin.OrderItem;

import javax.persistence.*;
import java.util.List;

public class JpaMain {
    public static void main(String[] args) {

        EntityManagerFactory emf1 = Persistence.createEntityManagerFactory("hello");

        EntityManager em1 = emf1.createEntityManager();

        EntityTransaction tx1 = em1.getTransaction();
        tx1.begin();

        try {
            Member findMember=em1.find(Member.class,2L);
            findMember.setNickName("만두");

        } catch (Exception e) {
            tx1.rollback();

        } finally {
            em1.close();

        }
        emf1.close();

    }
}
```

```java
Hibernate: 
    /* update
        hellojpa.Member */ update
            Member 
        set
            name=? 
						nickName=?
        where
            id=?
```

실행결과를 보면 nickName 값만 변경했는데, 값이 똑같은 name 필드까지 변경값으로 넣어주고 있다.

위와 동일한 Entity에 DynamicUpdate 만 붙어주었다.

```java
package jpabook.jpashop.domin;

import org.hibernate.annotations.DynamicUpdate;

import javax.persistence.*;
import java.util.ArrayList;
import java.util.List;

@Entity
@DynamicUpdate
public class Member {

    @Id
    @GeneratedValue
    @Column(name="MEMBER_ID")
    private Long id;
    private String name;

    private String nickName;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getNickName() {
        return nickName;
    }

    public void setNickName(String nickName) {
        this.nickName = nickName;
    }
}
```

```java
Hibernate: 
    /* update
        hellojpa.Member */ update
            Member 
        set
						nickName=?
        where
            id=?
```

update 쿼리가 실제로 변경한 nickName만 필드를 변경하고 있다.

**성능문제**

나는 당연히, 변경된 필드만 update를 하는 DynamicUpdate가 성능상 훨씬 좋을 것이라고 생각했다.

하지만, DynamicUpdate는

1. 변경된 컬럼만 찾는다.
2. 변경되는 컬럼에 따라 쿼리가 변경된다.

두 과정을 거쳐야 하기에 하나의 테이블에 정말 여러개의 컬럼(여기서는 30개 이상이라고 한다…)이 있을 때, 특정 컬럼만이 자주 변경된다면 그때 사용하는 것이 좋다고 한다.

 

### **3.4.4 엔티티 삭제**

엔티티를 삭제하려면 먼저 삭제 대상 엔티티를 조회해야 한다.

```java
Member memberA = em.find(Member.class, 100L);  // 삭제 대상 엔티티 조회
em.remove(memberA);     // 엔티티 삭제

```

- 엔티티를 즉시 삭제하는 것이 아님
- 삭제 쿼리를 쓰기 지연 SQL 저장소에 등록
- em.remove(memberA)를 호출하는 순간 영속성 컨텍스트에서 제거



현재 spring boot를 쓰지 않았는데, 추후 spring boot에서 이 영속성 컨텍스트를 생성해주고 관리해주는 걸 누가 하고 있는지 알고 싶다.