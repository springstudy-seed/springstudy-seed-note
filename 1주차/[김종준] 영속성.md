## 영속성

---



### 기본 설정

---



#### 라이브러리

---

우선 영속성에 대해 알아보기 위해서 JAP 하이버네이트, H2 라이브러리를 다음과 같이 추가해주어야 한다.

```xml
    <dependencies>
        <!-- JPA 하이버네이트 -->
        <dependency>
            <groupId>org.hibernate</groupId>
            <artifactId>hibernate-entitymanager</artifactId>
            <version>5.6.10.Final</version>
        </dependency>
        <!-- H2 데이터베이스 -->
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <version>2.1.214</version>
        </dependency>
    </dependencies>
```



#### persistence.xml

---

JPA는 META-INF 아래의 persistence.xml을 사용해서 필요한 설정 정보를 관리하기 때문에 persistence.xml을 다음과 같이 만들어 준다.

```xml
<?xml version="1.0" encoding="UTF-8"?>
<persistence version="2.2"
             xmlns="http://xmlns.jcp.org/xml/ns/persistence" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd">
    <persistence-unit name="hello">
        <properties>
            <!-- 필수 속성 -->
            <property name="javax.persistence.jdbc.driver" value="org.h2.Driver"/>
            <property name="javax.persistence.jdbc.user" value="sa"/>
            <property name="javax.persistence.jdbc.password" value=""/>
            <property name="javax.persistence.jdbc.url" value="jdbc:h2:tcp://localhost/~/test"/>
            <property name="hibernate.dialect" value="org.hibernate.dialect.H2Dialect"/>
            <!-- 옵션 -->
            <property name="hibernate.show_sql" value="true"/>
            <property name="hibernate.format_sql" value="true"/>
            <property name="hibernate.use_sql_comments" value="true"/>
            <property name="hibernate.jdbc.batch_size" value="10"/>
<!--            <property name="hibernate.hbm2ddl.auto" value="create"/>-->
        </properties>
    </persistence-unit>
</persistence>
```



##### \<persistence-unit>

----

연결할 데이터베이스의 영속성 유닛 등록을 위한 속성이다.



##### 사용한 속성

---

- JPA 표준 속성
  - javax.persistence.jdbc.driver : JDBC 드라이버
  - javax.persistence.jdbc.user : 데이터베이스 접속 아이디
  - javax.persistence.jdbc.password : 데이터베이스 접속 비밀번호
  - javax.persistence.jdbc.url : 데이터베이스 접속 URL
- 하이버네이트 설정
  - hibernate.dialect : 데이터베이스 방언 설정



##### 하이버네이트 설정 옵션

---

옵션

- hibernate.show_sql : 실행한 SQL을 출력.
- hibernate.format_sql : SQL을 보기 좋게 정렬함.
- hibernate.use_sql_comments : 쿼리 출력 시 주석도 함께 출력
- hibernate.id.new_generator_mappings : JPA 표준에 맞는 새로운 키 생성 전략을 사용함.

하이버네이트 설정

- create : Session factory가 실행될 때에 스키마를 지우고 다시 생성. 클래스패스에 import.sql 이 존재하면 찾아서, 해당 SQL도 함께 실행함.
- create-drop : create와 같지만 session factory가 내려갈 때 스키마 삭제.
- update : 시작시, 도메인과 스키마 비교하여 필요한 컬럼 추가 등의 작업 실행. 데이터는 삭제하지 않음.
- validate : Session factory 실행시 스키마가 적합한지 검사함. 문제가 있으면 예외 발생.
- 개발시에는 create가, 운영시에는 auto 설정을 빼거나 validate 정도로 두는 것이 좋아 보인다. update로 둘 경우에, 개발자들의 스키마가 마구 꼬여서 결국은 drop 해서 새로 만들어야 하는 사태가 발생한다.



### EntityManagerFactory

---

EntityManagerFactory는 다음과 같이 만들 수 있다.

```java
EntityManagerFactory emf = Persistence.createEntityManagerFactory("hello");
```

이는 \<persistence-unit>를 통해 등록한 영속성 유닛을 사용하는 것이다.

EntityManagerFactory는 만드는 비용이 상당히 크다.

하지만 여러 스레드가 동시에 접근해도 안전하고 서로 다른 스레드 간 공유 가능하다.

그렇기에 한 개만 만들어서 어플리케이션 전체에서 공유하도록 설계하여 한다.

이렇게 만든 EntityManagerFactory를 통해 우리는 실질적으로 엔티티를 관리해주는 EntityManager를 만들 수 있게 된다.



### EntityManager

---

EntityManager 내부에는 영속성 컨텍스트가 있어, 이를 통해 엔티티를 관리할 수 있다.

이러한 EntityManager은 다음과 같이 만들 수 있다.

```java
EntityManager em = emf.createEntityManager();
```



사진으로 보면 EntityManagerFactory와 EntityManager은 다음과 같은 관계를 가지는 것이다.

![영속성01](https://raw.githubusercontent.com/belljun3395/typoraImage/main/image/영속성01.png)



### 영속성 컨텍스트

---

영속성 컨텍스트는 엔티티를 영구 저장하는 환경이다.

이는 Java 영역에서 데이터를 관리하여 DB 접근을 최적화 하는 역할을 담당하고 있다.



#### 생명주기

---

엔티티는 다음 4가지 상태가 존재한다고 한다.

- 비영속
  - 영속성 컨텍스트와 연관이 없는 상태
- 영속
  - 영속성 컨텍스트에 저장된 상태
  - 엔티티가 영속성 컨텍스트에 의해 관리된다.
  - DB에 저장 되지는 않는다. 트랜잭션의 커밋 시점에 영속성 컨텍스트에 있는 정보들이 DB에 쿼리로 날아간다.
- 준영속
  - 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제
  - 영속성 컨텍스트에서 완전히 삭제된 상태



##### 영속

---

영속 상태가 되기 위해서는 EntittyManager의 persist 메소드를 활용하여 영속 상태가 될 수 있다.

```java
em.persist(someEntity);
```

이렇게 등록된 엔티티는 id 필드가 존재하여야 한다.

이는 JPA가 영속 상태의 엔티티를 관리하기 위해 id 필드가 존재하지 않으면 예외를 뱉어내기 때문이다.

이를 고려하여 영속 상태로 만들어 주면 다음과 같은 장점을 얻는다.



###### 1차 캐시

---

1차 캐시는 영속성 컨텍스트 내부에 존재한다.

엔티티를 영속성 컨텍스트에 저장하는 순간 1차 캐시에 `{ key : @Id로 선언한 필드 값, value : 해당 엔티티 자체 }`를 저장한다.

![영속성02](https://raw.githubusercontent.com/belljun3395/typoraImage/main/image/영속성02.png)



이렇게 저장된 1차 캐시는 특히 조회할 때 이점을 가진다.

`em.find()` 가 일어나는 순간 엔티티 매니저는 내부의 1차 캐시를 먼저 찾는다.

1차 캐시에 엔티티가 존재하면 바로 반환하고 DB를 들리지 않는다.



그렇다면 1차 캐시에 데이터가 없다면 어떻게 할까?

이때는 데이터베이스에서 조회하여 정보를 꺼내오고 그것을 1차 캐시에 저장한 후 반환한다.



다만 1차 캐시는 글로벌하지 않고 해당 스레드 하나가 시잘할때 부터 끝날때 까지 잠깐 쓰는 것이다. 

공유하지 않는 캐시이다.



###### 동일성 보장

---

1차 캐시 덕분에 같은 데이터를 두번 조회해도 다른 객체가 아니다.

1차 캐시의 같은 레퍼런스를 가진다.

1차 캐시로 반복 가능한 읽기 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 애플리케이션 차원에서 제공한다.



###### 트랜잭션을 지원하는 쓰기 지연(transactional write-behind) - 엔티티 등록

---

![영속성03](https://raw.githubusercontent.com/belljun3395/typoraImage/main/image/영속성03.png)

트랜잭션 내부에서 `em.persist()`가 일어날 때, 엔티티들은 1차 캐시에 저장하고, 논리적으로 쓰기 지연 SQL 저장소라는 곳에 INSERT 쿼리들을 생성해서 쌓아 놓는다.

DB에 바로 넣지 않고 기다리는 것이다.

이렇게 SQL 저장소에 쌓여있는 쿼리를 DB에 보내는 동작이 `em.flush()`이다.

`flush()`를 한다고 1차 캐시가 지워지지는 않고 쿼리들을 DB에 날려 DB와 싱크를 맞추는역활을 하는 것이다.

이렇게 `flush()`를 통해 쿼리를 보내고 나서 `tx.commit()`을 한다.

즉 트랜잭션을 커밋하게 되면, `flush()`와 `commit()` 두 가지 일을 하게 되는 것이다.



###### 변경 감지(Dirty Checking) - 엔티티 수정

---

엔티티 수정이 일어나면 `update()`나 `persist()`로 영속성을 컨택스트에 알려줄 필요가 없다.

엔티티 데이터만 수정하면 된다.

데이터만 set하고 트랜잭션을 커밋하면 자동으로 업데이트 쿼리가 나간다.

이는 Dirty Checking이라는 변경 감지를 통해서 가능한 것이다.

1차 캐시에 저장할 때 동시에 스냅샷 필드도 저장한다.

그리고 `commit()` 혹은 `flush()`가 일어날 때 엔티티와 스냅샷을 비교해서, 변경사항이 있으면 UPDATE SQL을 알아서 만들어 DB에 저장하는 것이다.



##### 플러시

---

플러시는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영한다.

트랜잭션 커밋이 일어날 때 플러시가 동작하는데, 쓰기 지연 저장소에 쌓아 놨던 INSERT, UPDATE, DELETE SQL들이 데이터베이스에 날라간다.

쉽게 얘기해서 영속성 컨텍스트의 변경 사항들과 데이터베이스를 싱크하는 작업이다.



###### 플러시 발생

---

- 플러시 발생플러시가 발생하면 어떤 일이 생기는지 변경을 감지한다.
- 수정된 엔티티를 쓰기 지연 SQL 저장소에 등록한다.
- 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송한다.
- (등록, 수정, 삭제 SQL)플러시가 발생한 다고 커밋이 이루어지는게 아니고, 플러시 다음에 커밋이 일어난다.



###### 영속성 컨텍스트를 flush 하는 방법

---

- em.flush()로 직접호출
- 트랜잭션 커밋시 자동호출
- JPQL 쿼리 실행시 자동호출



##### 준영속 컨텍스트

---

영속 상태의 엔티티가 영속성 컨텍스트에서 분리된 상태이다.

`em.detach()`로 영속성 컨텍스트에서 분리 할 수 있다.

그렇기에 트랜잭션을 커밋하면, 아무 일도 일어나지 않는다.

JPA가 관리하지 않는 객체인 것이다.



###### 준영속 상태로 만드는 방법

---

- em.detach(entity)
- em.clear()
- em.close()



### 코드 예제

---

이제 코드를 통해 영속성에 대해 조금 더 알아보자.



우선 프로젝트 구조이다.

![영속성04](https://raw.githubusercontent.com/belljun3395/typoraImage/main/image/영속성04.png)



엔티티인 Member 클래스는 다음과 같다.

```java
package hellojpa;

import javax.persistence.*;

@Entity
        public class Member {
        @Id
        @GeneratedValue(strategy = GenerationType.SEQUENCE)
        private Long id;
    @Column(name = "name", nullable = false)
    private String username;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

}
```



이를 실행한 JpaMain은 다음과 같다.

```java
package hellojpa;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.EntityTransaction;
import javax.persistence.Persistence;

public class JpaMain {
    public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("hello");
        EntityManager em = emf.createEntityManager();
        EntityTransaction tx = em.getTransaction();

        tx.begin();
        try {

            Member member = new Member();
            member.setUsername("A");
            em.persist(member);
            System.out.println("========================");
            Member findMember = em.find(Member.class, 1L);
            System.out.println("findMember.getId() = " + findMember.getId());
            System.out.println("========================");
            tx.commit();

        } catch (Exception e) {
            tx.rollback();
        } finally {
            em.close();
        }
        emf.close();
    }
}
```



JpaMain의 실행 결과는 다음과 같다.

![영속성05](https://raw.githubusercontent.com/belljun3395/typoraImage/main/image/영속성05.png)



이때 주목해야할 것은 쿼리가 나간 시점이다.

위에서 알아본 것처럼 `em.persist(member)`가 아니라 `tx.commit()` 이후에 쿼리가 나갔다.

`em.find(Member.class, 1L)` 는 `em.persist(member)` 을 통해 1차 캐시에 등록된 값에서 찾아온 것이다.

그렇기에 쿼리가 나가지 않았지만 `.getId()`를 할 수 있던 것이다.



기본적인 상황을 코드를 통해 알아보았으니 이제 공부를 하면서 궁금했던 상황들을 코드를 통해 확인해 보자.



#### 만약 EntittyManagerFactory가 서로 다른 2개라면?

---

이를 위해서 persistence.xml에 다음과 같이 \<persistence-unit>을 추가해 주어야한다.

```xml
<?xml version="1.0" encoding="UTF-8"?>
<persistence version="2.2"
             xmlns="http://xmlns.jcp.org/xml/ns/persistence" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd">
    <persistence-unit name="hello">
        <properties>
            <!-- 필수 속성 -->
            <property name="javax.persistence.jdbc.driver" value="org.h2.Driver"/>
            <property name="javax.persistence.jdbc.user" value="sa"/>
            <property name="javax.persistence.jdbc.password" value=""/>
            <property name="javax.persistence.jdbc.url" value="jdbc:h2:tcp://localhost/~/test"/>
            <property name="hibernate.dialect" value="org.hibernate.dialect.H2Dialect"/>
            <!-- 옵션 -->
            <property name="hibernate.show_sql" value="true"/>
            <property name="hibernate.format_sql" value="true"/>
            <property name="hibernate.use_sql_comments" value="true"/>
            <property name="hibernate.jdbc.batch_size" value="10"/>
<!--            <property name="hibernate.hbm2ddl.auto" value="create"/>-->
        </properties>
    </persistence-unit>
    <persistence-unit name="hello2">
        <properties>
            <!-- 필수 속성 -->
            <property name="javax.persistence.jdbc.driver" value="org.h2.Driver"/>
            <property name="javax.persistence.jdbc.user" value="sa"/>
            <property name="javax.persistence.jdbc.password" value=""/>
            <property name="javax.persistence.jdbc.url" value="jdbc:h2:tcp://localhost/~/test"/>
            <property name="hibernate.dialect" value="org.hibernate.dialect.H2Dialect"/>
            <!-- 옵션 -->
            <property name="hibernate.show_sql" value="true"/>
            <property name="hibernate.format_sql" value="true"/>
            <property name="hibernate.use_sql_comments" value="true"/>
            <property name="hibernate.jdbc.batch_size" value="10"/>
            <!--            <property name="hibernate.hbm2ddl.auto" value="create"/>-->
        </properties>
    </persistence-unit>
</persistence>
```



코드는 다음과 같다.

```java
package hellojpa;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.EntityTransaction;
import javax.persistence.Persistence;

public class TestMain {
    public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("hello");
        EntityManager em = emf.createEntityManager();
        EntityTransaction tx = em.getTransaction();

        EntityManagerFactory emf2 = Persistence.createEntityManagerFactory("hello2");
        EntityManager em2 = emf2.createEntityManager();
        EntityTransaction tx2 = em2.getTransaction();

        tx.begin();
        tx2.begin();
        try {
            Member member1 = em.find(Member.class, 1L);
            System.out.println("member1.getUsername() = " + member1.getUsername());
            member1.setUsername("하나");
            System.out.println("========================");
            Member member2 = em2.find(Member.class, 1L);
            System.out.println("member2.getUsername() = " + member2.getUsername());
            member2.setUsername("둘");
            System.out.println("========================");
            System.out.println("member1 == member2 : " + (member1 == member2));
            System.out.println("========================");
            tx.commit();
            System.out.println("========================");
            tx2.commit();
            System.out.println("========================");
        } catch (Exception e) {
            tx.rollback();
            tx2.rollback();
        } finally {
            em.close();
            em2.close();
        }
        emf.close();
        emf2.close();
    }
}
```

 

이는 다음과 같은 결과가 나온다.

```
Hibernate: 
    select
        member0_.id as id1_0_0_,
        member0_.name as name2_0_0_ 
    from
        Member member0_ 
    where
        member0_.id=?
member1.getUsername() = A
========================
Hibernate: 
    select
        member0_.id as id1_0_0_,
        member0_.name as name2_0_0_ 
    from
        Member member0_ 
    where
        member0_.id=?
member2.getUsername() = A
========================
member1 == member2 : false
========================
========================
Hibernate: 
    /* update
        hellojpa.Member */ update
            Member 
        set
            name=? 
        where
            id=?
========================
```

em 그리고 em2 모두 Id 값이 1인 것을 조회하여 그것의 Username이 A라는 것을 확인해 주었다.

하지만 이 둘은 서로 다른 영속성 컨텍스트에서 꺼내온 것이기 때문에 `member1 == member2 : false` 라는 결과가 나왔다.



결과에서 가장 의문이 드는 곳은 update 쿼리가 1개만 나간 것이다.

`tx.commit()`의 쿼리는 나가지 않고 `tx2.commit()` 쿼리만 나갔다.

이는 추후 조금 더 공부를 해보고 해결해 보아야 할 것 같다.



#### 만약 EntityManager이 서로 다른 2개라면?

---

이를 확인하기 위한 코드는 다음과 같다.

```java
package hellojpa;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.EntityTransaction;
import javax.persistence.Persistence;

public class TestMain {
    public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("hello");
        EntityManager em = emf.createEntityManager();
        EntityManager em2 = emf.createEntityManager();
        EntityTransaction tx = em.getTransaction();
        EntityTransaction tx2 = em2.getTransaction();

        tx.begin();
        tx2.begin();
        try {
            Member member1 = em.find(Member.class, 1L);
            System.out.println("member1.getUsername() = " + member1.getUsername());
            member1.setUsername("하나");
            System.out.println("========================");
            Member member2 = em2.find(Member.class, 1L);
            System.out.println("member2.getUsername() = " + member2.getUsername());
            member2.setUsername("둘");
            System.out.println("========================");
            System.out.println("member1 == member2 : " + (member1 == member2));
            System.out.println("========================");
            tx.commit();
            System.out.println("========================");
            tx2.commit();
            System.out.println("========================");
        } catch (Exception e) {
            tx.rollback();
            tx2.rollback();
        } finally {
            em.close();
            em2.close();
        }
        emf.close();
    }
}
```



이는 다음과 같은 결과를 얻는다.

```
Hibernate: 
    select
        member0_.id as id1_0_0_,
        member0_.name as name2_0_0_ 
    from
        Member member0_ 
    where
        member0_.id=?
member1.getUsername() = A
========================
Hibernate: 
    select
        member0_.id as id1_0_0_,
        member0_.name as name2_0_0_ 
    from
        Member member0_ 
    where
        member0_.id=?
member2.getUsername() = A
========================
member1 == member2 : false
========================
Hibernate: 
    /* update
        hellojpa.Member */ update
            Member 
        set
            name=? 
        where
            id=?
========================
Hibernate: 
    /* update
        hellojpa.Member */ update
            Member 
        set
            name=? 
        where
            id=?
========================
```



H2도 확인해 보면 다음과 같다.

![영속성06](https://raw.githubusercontent.com/belljun3395/typoraImage/main/image/영속성06.png)



하나 위의 결과에서 주목하고 싶은 부분은 "만약 EntittyManagerFactory가 서로 다른 2개라면"에서의 결과와 다르게 update 쿼리가 2번 나갔다는 것이다.



"만약 EntittyManagerFactory가 서로 다른 2개라면"과 "만약 EntityManager이 서로 다른 2개라면?"의 차이 역시 추후 공부를 통해 해결하여야 할 것 같다.



#### 질문 해결

----

EntityManagerFactory는 DB당 하나만 연결된다고 한다.

그래서 위의 코드의 `Member member2 = em2.find(Member.class, 1L);`  순간에 emf와 DB의 연결은 끊어지고 emf2와 DB와 연결되는 것이다.

그래서 `commit` 시점을 다음과 같이 바꾸면 update 쿼리가 두번 나가는 것을 볼 수 있다.

```java
package hellojpa;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.EntityTransaction;
import javax.persistence.Persistence;

public class TestMain {
    public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("hello");
        EntityManager em = emf.createEntityManager();
        EntityTransaction tx = em.getTransaction();

        EntityManagerFactory emf2 = Persistence.createEntityManagerFactory("hello2");
        EntityManager em2 = emf2.createEntityManager();
        EntityTransaction tx2 = em2.getTransaction();

        tx.begin();
        tx2.begin();
        try {
            Member member1 = em.find(Member.class, 1L);
            System.out.println("member1.getUsername() = " + member1.getUsername());
            member1.setUsername("하나");
			System.out.println("========================");
            tx.commit();
            System.out.println("========================");
            Member member2 = em2.find(Member.class, 1L);
            System.out.println("member2.getUsername() = " + member2.getUsername());
            member2.setUsername("둘");
            System.out.println("========================");
            System.out.println("member1 == member2 : " + (member1 == member2));
            System.out.println("========================");
            tx2.commit();
            System.out.println("========================");
        } catch (Exception e) {
            tx.rollback();
            tx2.rollback();
        } finally {
            em.close();
            em2.close();
        }
        emf.close();
        emf2.close();
    }
}
```

```
Hibernate: 
    select
        member0_.id as id1_0_0_,
        member0_.name as name2_0_0_ 
    from
        Member member0_ 
    where
        member0_.id=?
member1.getUsername() = A
========================
Hibernate: 
    /* update
        hellojpa.Member */ update
            Member 
        set
            name=? 
        where
            id=?
=======================
Hibernate: 
    select
        member0_.id as id1_0_0_,
        member0_.name as name2_0_0_ 
    from
        Member member0_ 
    where
        member0_.id=?
member2.getUsername() = A
========================
member1 == member2 : false
========================
Hibernate: 
    /* update
        hellojpa.Member */ update
            Member 
        set
            name=? 
        where
            id=?
=======================
```



#### 영속성 컨텍스트 등록순서

---

아마 당연하다 생각할 수 있지만 영속성 컨텍스트를 너무 믿고 `em.find`를 먼저하고 `em.persist`를 하면 어떻게 되는지 알아보았다.



이를 확인하기 위한 코드는 다음과 같다.

```java
package hellojpa;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.EntityTransaction;
import javax.persistence.Persistence;

public class TestMain {
    public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("hello");
        EntityManager em = emf.createEntityManager();
        EntityTransaction tx = em.getTransaction();

        tx.begin();
        try {
            Member findMember = em.find(Member.class, 2L);
            System.out.println("findMember.getUsername() = " + findMember.getUsername());
            System.out.println("==============================");
            Member member = new Member();
            member.setUsername("B");
            em.persist(member);
            System.out.println("==============================");
            tx.commit();
        } catch (Exception e) {
            System.out.println("==============================");
            System.out.println("e = " + e);
            tx.rollback();
        } finally {
            em.close();
        }
        emf.close();
    }
}
```



이를 실행한 결과는 다음과 같다.

```
Hibernate: 
    select
        member0_.id as id1_0_0_,
        member0_.name as name2_0_0_ 
    from
        Member member0_ 
    where
        member0_.id=?
==============================
e = java.lang.NullPointerException
```



`em.find(Member.class, 1L)` 에서 `java.lang.NullPointerException` 이 발생하여 이후의 쿼리를 실행되지도 않았다.

임시 SQL문 저장소가 있으니 EntityManager가 이 순서를 적절히 조절해서 결과를 반환 받을 수 있지 않을까? 하고 생각하였는데 그렇지 않았다.



#### 만약 한 트랜잭션안에서 조회-수정-조회 를 한다면?

---

이를 확인하기 위한 코드는 다음과 같다.

```java
package hellojpa;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.EntityTransaction;
import javax.persistence.Persistence;

public class TestMain {
    public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("hello");
        EntityManager em = emf.createEntityManager();
        EntityTransaction tx = em.getTransaction();

        tx.begin();
        try {
            Member member = em.find(Member.class, 1L);
            System.out.println("member.getUsername() = " + member.getUsername());
            System.out.println("==============================");
            member.setUsername("하나");
            System.out.println("member.getUsername() = " + member.getUsername());
            System.out.println("==============================");
            Member findMember = em.find(Member.class, 1L);
            System.out.println("findMember.getUsername() = " + findMember.getUsername());
            System.out.println("==============================");
            tx.commit();
        } catch (Exception e) {
            tx.rollback();
        } finally {
            em.close();
        }
        emf.close();
    }
}
```



이 코드의 결과는 다음과 같다.

```
Hibernate: 
    select
        member0_.id as id1_0_0_,
        member0_.name as name2_0_0_ 
    from
        Member member0_ 
    where
        member0_.id=?
member.getUsername() = A
==============================
member.getUsername() = 하나
==============================
findMember.getUsername() = 하나
==============================
Hibernate: 
    /* update
        hellojpa.Member */ update
            Member 
        set
            name=? 
        where
            id=?
```



위의 결과에서 주목할 부분은 `Member findMember = em.find(Member.class, 1L);` 이후에 update 쿼리가 나간다는 것이다.

그렇지만 `findMember.getUsername() = 하나` 를 보면 알 수 있듯 수정된 값이 반영되었다.



이는 위에서 공부한 `em.find()` 가 일단 1차 캐시를 먼저 확인하기 때문에 나온 결과이다.

1차 캐시에는 update가 미리 반영되어 있기 때문이다.

update쿼리는 jpa가 쿼리를 DB에 보내기 전에 더티체킹을 하여 username의 변화를 감지하고 이를 반영하여 자동으로 SQL문을 작성하여 DB로 보낸 것이다.
